
----------------------------
Python performances Notes
----------------------------

1. Measuring performance
    Various Approch to understand performances 
        1. time() function
        2. timeit module 
        3. pytest-benchmark plugin for pytest  

        mprofile and cprofile can be used
        mprofile adds significant overhead and easy to extend whereas cProfile adds less overhead and general purpose 

    Usage of time module.
        mpatel@blr-mpd67 demos % cat empty_loop.py 
        import time


        def heavy_work():
            for _ in range(100_000_000):
                pass

        start_time = time.time()
        heavy_work()
        end_time = time.time()
        print(f'Duration: {end_time - start_time}')
        mpatel@blr-mpd67 demos % python3 empty_loop.py 
        Duration: 2.1028521060943604

    Usage of timeit module.
        % python3 -m timeit -c "for _ in range(100_000_000): pass"
        1 loop, best of 5: 2.02 sec per loop

    Usage of pytest 
        % pytest test_empty_loop.py
        =================================================================================================================== test session starts ====================================================================================================================
        platform darwin -- Python 3.11.3, pytest-7.4.3, pluggy-1.3.0
        benchmark: 4.0.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
        rootdir: /Users/mpatel/git/PycharmProjects/pluralSightDoc/python-3-performance/02/demos
        plugins: benchmark-4.0.0
        collected 1 item                                                                                                                                                                                                                                           

        test_empty_loop.py .                                                                                                                                                                                                                                 [100%]


        ----------------------------------------------- benchmark: 1 tests -----------------------------------------------
        Name (time in s)                 Min     Max    Mean  StdDev  Median     IQR  Outliers     OPS  Rounds  Iterations
        ------------------------------------------------------------------------------------------------------------------
        test_benchmark_heavy_work     1.9996  2.0830  2.0280  0.0365  2.0062  0.0548       1;0  0.4931       5           1
        ------------------------------------------------------------------------------------------------------------------

        Legend:
        Outliers: 1 Standard Deviation from Mean; 1.5 IQR (InterQuartile Range) from 1st Quartile and 3rd Quartile.
        OPS: Operations Per Second, computed as 1 / Mean
        ==================================================================================================================== 1 passed in 17.23s ====================================================================================================================

        % cat test_empty_loop.py
        from empty_loop import heavy_work

        def test_benchmark_heavy_work(benchmark):
            benchmark(heavy_work)

    Profiler out puts and overall cProfile is better choice as its faster. 
        % python3 -m cProfile sum_loop.py 
        Duration:  34.82 seconds
                100000007 function calls in 34.819 seconds

        Ordered by: cumulative time

        ncalls  tottime  percall  cumtime  percall filename:lineno(function)
                1    0.000    0.000   34.819   34.819 {built-in method builtins.exec}
                1    0.000    0.000   34.819   34.819 sum_loop.py:1(<module>)
                1   24.542   24.542   34.819   34.819 sum_loop.py:4(heavy_work)
        100000000   10.276    0.000   10.276    0.000 sum_loop.py:9(do_stuff)
                1    0.000    0.000    0.000    0.000 {built-in method builtins.print}
                2    0.000    0.000    0.000    0.000 {built-in method time.time}
                1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}

        % python3 -m profile sum_loop.py 
        Duration:  545.39 seconds
                100000008 function calls in 230.181 seconds

        Ordered by: standard name

        ncalls  tottime  percall  cumtime  percall filename:lineno(function)
                1    0.000    0.000  230.168  230.168 :0(exec)
                1    0.000    0.000    0.000    0.000 :0(print)
                1    0.013    0.013    0.013    0.013 :0(setprofile)
                2    0.000    0.000    0.000    0.000 :0(time)
                1    0.000    0.000  230.181  230.181 profile:0(<code object <module> at 0x1032ab210, file "sum_loop.py", line 1>)
                0    0.000             0.000          profile:0(profiler)
                1    0.000    0.000  230.168  230.168 sum_loop.py:1(<module>)
                1  122.164  122.164  230.168  230.168 sum_loop.py:4(heavy_work)
        100000000  108.004    0.000  108.004    0.000 sum_loop.py:9(do_stuff)

    Third party profilers --> Line_profiler, Py-spy, Scalene, Yappi, Memory_profiler

        Line_profiler:
            % pip3 install line_profiler
            % kernprof -lv large_function.py 
            Do something
            Do something
            Do something
            Do something
            Do something
            Duration: 107.20122194290161
            Wrote profile results to large_function.py.lprof
            Timer unit: 1e-06 s

            Total time: 46.9882 s
            File: large_function.py
            Function: heavy_work at line 4

            Line #      Hits         Time  Per Hit   % Time  Line Contents
            ==============================================================
                4                                           @profile
                5                                           def heavy_work():
                6         1         33.0     33.0      0.0      print('Do something')
                7         1          5.0      5.0      0.0      print('Do something')
                8         1          3.0      3.0      0.0      print('Do something')
                9                                           
                10 100000001   25940663.0      0.3     55.2      for _ in range(100_000_000):
                11 100000000   21047451.0      0.2     44.8          pass
                12                                           
                13         1         26.0     26.0      0.0      print('Do something')
                14         1         23.0     23.0      0.0      print('Do something')

            % cat large_function.py
            import time


            @profile
            def heavy_work():
                print('Do something')
                print('Do something')
                print('Do something')

                for _ in range(100_000_000):
                    pass

                print('Do something')
                print('Do something')

            start_time = time.time()
            heavy_work()
            end_time = time.time()
            print(f'Duration: {end_time - start_time}')

        Memory_profiler
            % pip3 install memory_profiler

            % cat memory_intensive.py 
            @profile
            def create_big_list():
                return 10_000_000 * [0]

            @profile
            def create_huge_list():
                return 30_000_000 * [0]

            create_big_list()
            create_huge_list()

            % python3 -m memory_profiler memory_intensive.py 
            Filename: memory_intensive.py

            Line #    Mem usage    Increment  Occurrences   Line Contents
            =============================================================
                1   43.707 MiB   43.707 MiB           1   @profile
                2                                         def create_big_list():
                3  120.004 MiB   76.297 MiB           1       return 10_000_000 * [0]


            Filename: memory_intensive.py

            Line #    Mem usage    Increment  Occurrences   Line Contents
            =============================================================
                5  120.008 MiB  120.008 MiB           1   @profile
                6                                         def create_huge_list():
                7  348.891 MiB  228.883 MiB           1       return 30_000_000 * [0]

    Snakeviz - graphical profiler 
        % pip3 install matplotlib

        demos %  mprof run memory_intensive.py 
        mprof: Sampling memory every 0.1s
        running new process
        running as a Python program...
        demos % mprof plot --output memory_intensive.jpg
        Using last profile data.
        demos % open memory_intensive.jpg 

        mpatel@blr-mpd67 demos % pip3 install snakeviz
        mpatel@blr-mpd67 demos % python3 -m cProfile -o sum_loop.prof sum_loop.py 
        Duration:  33.61 seconds
        mpatel@blr-mpd67 demos % snakeviz sum_loop.prof 
        snakeviz web server started on 127.0.0.1:8080; enter Ctrl-C to exit
        http://127.0.0.1:8080/snakeviz/%2FUsers%2Fmpatel%2Fgit%2FPycharmProjects%2FpluralSightDoc%2Fpython-3-performance%2F02%2Fdemos%2Fsum_loop.prof


2. Using right Data structures
    Big O Notation
        #Constant O(1)
            amounts = [3, 5, 7]
            double = amount[0] * 2
        #Linear O(n)
            sum = 0 
            for i in amounts:
                sum += i
        
        O(n^2)      O(n log(n))     O(n)    O(log n)    O(1)
        -------------------------------------------------------->
        Very slow                                       Very Fast

        mpatel@blr-mpd67 demos % python3 big_o.py 
        Duration double: 9.5367431640625e-07
        Duration sum: 6.794929504394531e-05
        Ratio of durations: 71.25
        mpatel@blr-mpd67 demos % cat big_o.py 
        import random
        import time


        def double_first_amount(amounts):
            return amounts[0] * 2

        def sum_odd_amounts(amounts):
            sum = 0
            for a in amounts:
                if a % 2:
                    sum += a
            return sum

        randomAmounts = [random.randint(1, 100) for _ in range(1000)]

        start_time = time.time()
        double_first_amount(randomAmounts)
        double_duration = time.time() - start_time

        start_time = time.time()
        sum_odd_amounts(randomAmounts)
        sum_duration = time.time() - start_time

        print(f'Duration double: {double_duration}')
        print(f'Duration sum: {sum_duration}')
        print(f'Ratio of durations: {sum_duration/double_duration:.2f}')

    List and Arrays are for holding more values.
        List
            Ordered Collections
            Allow Mixed types but always save same types so it allows python to do Optimization
            Implemented as resizable Arrays
            Very Fast -- O(1)
                Getting values
                Setting values
                Appending values
            Slow -- O(n)
                Finding a item
                removing a item
            Memory allocation
                Extra room for future appends
                Old list is copied to new list for larger values.
                keep an eye on multiple appends
        Arrays
            built-in Arrays
                Compact data storage, only for certain types and less popular
            NumPy Arrays
                Numeric computations items of different types and very popular
            
            #Demo to show numpy array are much faster then default list.
            mpatel@blr-mpd67 demos % cat list_array.py
            import numpy

            def double_list(size):
                initial_list = list(range(size))
                return [2 * i for i in initial_list]

            def double_array(size):
                initial_array = numpy.arange(size)
                return 2 * initial_array

            double_list(1_000_000)
            double_array(1_000_000) 
            mpatel@blr-mpd67 demos % python3 -m cProfile -o list_array.prof list_array.py 
            mpatel@blr-mpd67 demos % snakeviz list_array.prof 
            snakeviz web server started on 127.0.0.1:8080; enter Ctrl-C to exit
            http://127.0.0.1:8080/snakeviz/%2FUsers%2Fmpatel%2Fgit%2FPycharmProjects%2FpluralSightDoc%2Fpython-3-performance%2F03%2Fdemos%2Flist_array.prof
            ^C
            Bye!
            mpatel@blr-mpd67 demos %

    Sets and tuples
        Sets
            unordered collections of unique immutable items however sets are mutable like adding new items to set.
            Very Fast O(1):
                Adding
                Deleting
                Membership checking
            Slow - O(n):
                removing duplicate.
        Tuples
            immutable, Ordered collection, Fixed content so they are memory efficient 
        
        # Demo 
        # Set needs less memory then List but tuple is so much efficient
        # search inside set is very efficient compared to tuple.
        mpatel@blr-mpd67 demos % python3 -m memory_profiler set_tuple.py
        Filename: set_tuple.py

        Line #    Mem usage    Increment  Occurrences   Line Contents
        =============================================================
            11   42.738 MiB   42.738 MiB           1   @profile
            12                                         def main():
            13   42.738 MiB    0.000 MiB           1       SIZE = 1_000_000
            14                                         
            15   80.992 MiB   38.254 MiB           1       big_list = list(range(SIZE))
            16   88.625 MiB    7.633 MiB           1       big_tuple = tuple(big_list)
            17  151.156 MiB   62.531 MiB           1       big_set = set(big_list)
            18                                         
            19  151.188 MiB    0.031 MiB        1003       items_to_find = [random.randint(0, SIZE) for _ in range(1000)]
            20                                         
            21  151.188 MiB    0.000 MiB           1       search(items_to_find, big_tuple)
            22  151.188 MiB    0.000 MiB           1       search(items_to_find, big_set)
            23  151.188 MiB    0.000 MiB           1       search(items_to_find, big_list)


        mpatel@blr-mpd67 demos % kernprof -lv set_tuple.py
        Wrote profile results to set_tuple.py.lprof
        Timer unit: 1e-06 s

        Total time: 10.4118 s
        File: set_tuple.py
        Function: main at line 11

        Line #      Hits         Time  Per Hit   % Time  Line Contents
        ==============================================================
            11                                           @profile
            12                                           def main():
            13         1          0.0      0.0      0.0      SIZE = 1_000_000
            14                                           
            15         1      27904.0  27904.0      0.3      big_list = list(range(SIZE))
            16         1       6032.0   6032.0      0.1      big_tuple = tuple(big_list)
            17         1      46716.0  46716.0      0.4      big_set = set(big_list)
            18                                           
            19         1       3480.0   3480.0      0.0      items_to_find = [random.randint(0, SIZE) for _ in range(1000)]
            20                                           
            21         1    5145493.0    5e+06     49.4      search(items_to_find, big_tuple)
            22         1        442.0    442.0      0.0      search(items_to_find, big_set)
            23         1    5181765.0    5e+06     49.8      search(items_to_find, big_list)

        mpatel@blr-mpd67 demos % cat set_tuple.py
        import random


        def search(items, collection):
            count = 0
            for i in items:
                if i in collection:
                    count += 1
            return count

        @profile
        def main():
            SIZE = 1_000_000

            big_list = list(range(SIZE))
            big_tuple = tuple(big_list)
            big_set = set(big_list)

            items_to_find = [random.randint(0, SIZE) for _ in range(1000)]

            search(items_to_find, big_tuple)
            search(items_to_find, big_set)
            search(items_to_find, big_list)

        main()
        mpatel@blr-mpd67 demos %

    Queues and Deques
        Queue
            From queue module, simple queue data structure - FIFO, Specialized for multithreading and few operations
        Deque
            From collections module, Double eneded queue, FIFO as well LIFO (stack), multithreading support and more operations
            Deque                       | List
            Slow access by index - O(n) | Fast access by index - O(1)
            Fast append and pop at end  | Fast append and pop at end
            Fast append and pop at start| slow append and pop at start

        # Demo
        # avoid append at start of List as it takes lot of time 
        # deque are best option for append at start. 
            mpatel@blr-mpd67 demos % cat deque.py 
            from collections import deque


            @profile
            def main():
                SIZE = 100_000

                big_list = list(range(SIZE))
                big_queue = deque(big_list)

                while big_list:
                    big_list.pop()
                while big_queue:
                    big_queue.pop()
                
                big_list = list(range(SIZE))
                big_queue = deque(big_list)

                while big_list:
                    big_list.pop(0)
                while big_queue:
                    big_queue.popleft()


            main()
            mpatel@blr-mpd67 demos % kernprof -lv deque.py 
            Wrote profile results to deque.py.lprof
            Timer unit: 1e-06 s

            Total time: 1.11005 s
            File: deque.py
            Function: main at line 4

            Line #      Hits         Time  Per Hit   % Time  Line Contents
            ==============================================================
                4                                           @profile
                5                                           def main():
                6         1          0.0      0.0      0.0      SIZE = 100_000
                7                                           
                8         1       3062.0   3062.0      0.3      big_list = list(range(SIZE))
                9         1        977.0    977.0      0.1      big_queue = deque(big_list)
                10                                           
                11    100001      26349.0      0.3      2.4      while big_list:
                12    100000      33174.0      0.3      3.0          big_list.pop()
                13    100001      24634.0      0.2      2.2      while big_queue:
                14    100000      32068.0      0.3      2.9          big_queue.pop()
                15                                               
                16         1       2024.0   2024.0      0.2      big_list = list(range(SIZE))
                17         1        762.0    762.0      0.1      big_queue = deque(big_list)
                18                                           
                19    100001      27748.0      0.3      2.5      while big_list:
                20    100000     903668.0      9.0     81.4          big_list.pop(0)
                21    100001      24354.0      0.2      2.2      while big_queue:
                22    100000      31233.0      0.3      2.8          big_queue.popleft()

            mpatel@blr-mpd67 demos % 

    Dictionaries
        collections of key-value pair
        mutable (add, remove or update possible)
        keys are unique 
        need keys to access value
        Keys must be hashable.
        Very popular 
        Very fast - O(1) - Getting, Setting or Deleting
        Slow - O(n) - Worst case scenarios

        # Demo to see benefit compared to dict. 99.2% time spent for search in List.
            mpatel@blr-mpd67 demos % cat dictionary.py 
            import random

            def search_list(big_list, items):
                count = 0
                for item in items:
                    for order in big_list:
                        if item == order[0]:
                            count += 1
                return count

            def search_dictionary(some_dictionary, items):
                count = 0
                for item in items:
                    if item in some_dictionary:
                        count += 1
                return count

            @profile
            def main():
                SIZE = 100_000

                big_list = []
                big_dictionary = {}

                for i in range(SIZE):
                    big_list.append([i, 2 * i, i * i])
                    big_dictionary[i] = [2 * i, i * i]

                orders_to_search = [random.randint(0, SIZE) for _ in range(1000)]
                search_list(big_list, orders_to_search)
                search_dictionary(big_dictionary, orders_to_search)

            main()
            mpatel@blr-mpd67 demos % kernprof -lv dictionary.py 
            Wrote profile results to dictionary.py.lprof
            Timer unit: 1e-06 s

            Total time: 22.4539 s
            File: dictionary.py
            Function: main at line 18

            Line #      Hits         Time  Per Hit   % Time  Line Contents
            ==============================================================
                18                                           @profile
                19                                           def main():
                20         1          1.0      1.0      0.0      SIZE = 100_000
                21                                           
                22         1          0.0      0.0      0.0      big_list = []
                23         1          0.0      0.0      0.0      big_dictionary = {}
                24                                           
                25    100001      30192.0      0.3      0.1      for i in range(SIZE):
                26    100000      89238.0      0.9      0.4          big_list.append([i, 2 * i, i * i])
                27    100000      54191.0      0.5      0.2          big_dictionary[i] = [2 * i, i * i]
                28                                           
                29         1       2778.0   2778.0      0.0      orders_to_search = [random.randint(0, SIZE) for _ in range(1000)]
                30         1   22276672.0    2e+07     99.2      search_list(big_list, orders_to_search)
                31         1        779.0    779.0      0.0      search_dictionary(big_dictionary, orders_to_search)

            mpatel@blr-mpd67 demos % 

    Named Tuples, Data classe
        Named Tuples
            Tuples with named field, better readability, immutable, great at storing read only data like database reads, and functional agrument and memory efficient
        Data class 
            stores data with class without lots of boilerplate code
            Decorate class with @dataclass
            Optional immutability by default mutable
        
        # Demo : Dictionaries are fastest to created and named tuple take max time. (use -s to Measuring required part only ) where as accessing dataclass are fastest
            mpatel@blr-mpd67 demos % python3 -m timeit '{"order_id":1}'
            5000000 loops, best of 5: 46.7 nsec per loop
            mpatel@blr-mpd67 demos % python3 -m timeit -s 'from collections import namedtuple; Order=namedtuple("Order", "order_id")' 'Order(1)'
            1000000 loops, best of 5: 228 nsec per loop
            mpatel@blr-mpd67 demos % python3 -m timeit -s """                                                                                   
            dquote> from dataclasses import dataclass
            dquote> @dataclass
            dquote> class order:
            dquote>   order_id: int
            dquote> """ 'order(1)'
            2000000 loops, best of 5: 156 nsec per loop
            mpatel@blr-mpd67 demos %

            #accessing objects 
            mpatel@blr-mpd67 demos % python3 -m timeit -s 'order={"order_id":1}' 'order["order_id"]'
            10000000 loops, best of 5: 24.6 nsec per loop
            mpatel@blr-mpd67 demos % python3 -m timeit -s 'from collections import namedtuple; Order=namedtuple("Order", "order_id"); Order(1)' 'Order.order_id'
            10000000 loops, best of 5: 25.4 nsec per loop            
            mpatel@blr-mpd67 demos % python3 -m timeit -s """
            from dataclasses import dataclass
            @dataclass
            class order:
            order_id: int
            order=order(1)""" 'order.order_id'
            20000000 loops, best of 5: 14 nsec per loop
            mpatel@blr-mpd67 demos %


3. Optimizing python code
    Caching
        Computing bottlenecks goes
        Network bottlenecks goes
        It will require Extra memory and data used will be old (storing stock market data)
        1. Basic approach for caching is with storing data dictionaries but it doesn't provide boundry check
        2. Use @lru_cache()
        3. Use third party module (joblib)

        # Demo to see usage of lru_cache and it speed up functions
            mpatel@blr-mpd67 demos % kernprof -lv caching.py 
            Wrote profile results to caching.py.lprof
            Timer unit: 1e-06 s

            Total time: 12.3601 s
            File: caching.py
            Function: main at line 10

            Line #      Hits         Time  Per Hit   % Time  Line Contents
            ==============================================================
                10                                           @profile
                11                                           def main():
                12         1       3516.0   3516.0      0.0      orders_to_search = [random.randint(0, 100) for _ in range(1000)]
                13      1001        455.0      0.5      0.0      for order in orders_to_search:
                14      1000   12356122.0  12356.1    100.0          get_order_details(order)

            mpatel@blr-mpd67 demos % vim caching.py         
            mpatel@blr-mpd67 demos % cat caching.py
            from functools import lru_cache
            import random

            @lru_cache
            def get_order_details(order_id):
                for i in range(100_000):
                    pass
                return 100 * order_id

            @profile
            def main():
                orders_to_search = [random.randint(0, 100) for _ in range(1000)]
                for order in orders_to_search:
                    get_order_details(order)

            main()
            mpatel@blr-mpd67 demos % kernprof -lv caching.py
            Wrote profile results to caching.py.lprof
            Timer unit: 1e-06 s

            Total time: 1.11511 s
            File: caching.py
            Function: main at line 10

            Line #      Hits         Time  Per Hit   % Time  Line Contents
            ==============================================================
                10                                           @profile
                11                                           def main():
                12         1       2996.0   2996.0      0.3      orders_to_search = [random.randint(0, 100) for _ in range(1000)]
                13      1001        279.0      0.3      0.0      for order in orders_to_search:
                14      1000    1111832.0   1111.8     99.7          get_order_details(order)

            mpatel@blr-mpd67 demos % 

    For vs List comprehension
        For loops offer more flexibity, better for more logic, lengthy and slower for simple logic
        List comprehensions are only for new list, great for simple logic, consice and fast.
        There are set and dict comprehensions as well

        # Demo
            mpatel@blr-mpd67 demos % kernprof -lv comprehension.py 
            Wrote profile results to comprehension.py.lprof
            Timer unit: 1e-06 s

            Total time: 0.32645 s
            File: comprehension.py
            Function: main at line 14

            Line #      Hits         Time  Per Hit   % Time  Line Contents
            ==============================================================
                14                                           @profile
                15                                           def main():
                16         1     280721.0 280721.0     86.0      orders = [random.randint(0, 100) for _ in range(100_000)]
                17         1      27829.0  27829.0      8.5      loop(orders)
                18         1      17900.0  17900.0      5.5      comprehension(orders)

            mpatel@blr-mpd67 demos % cat comprehension.py
            import random


            def loop(orders):
                result = []
                for amount in orders:
                    if amount > 50:
                        result.append(2 * amount)
                return result

            def comprehension(orders):
                return [2 * amount for amount in orders if amount > 50]

            @profile
            def main():
                orders = [random.randint(0, 100) for _ in range(100_000)]
                loop(orders)
                comprehension(orders)

            main()%                                                                                                                                                                                                                                                     
            mpatel@blr-mpd67 demos %

    Efficient iterations with generator
        Lazy version of comprehensions - less flexibity
        Avoid upfornt full creation 
        "Just in time" values - access only next item
        Example : Read lines from very large files
        generator expression allows no random access and iteration is only once.
        Example: (p * 2 for p in orders if p > 100)

        # Demo to see Time and memory performance - generator are lazy so it takes less time and memory but operation takes time

            mpatel@blr-mpd67 demos % cat generator.py 
            import random


            @profile
            def main():
                orders = [random.randint(0, 100) for _ in range(100_000)]

                comprehension = [2 * amount for amount in orders if amount > 50]
                generator = (2 * amount for amount in orders if amount > 50)

                sum(comprehension)
                sum(generator)


            main()%                                                                                                                                                                                                                                                     
            mpatel@blr-mpd67 demos % kernprof -lv generator.py 
            Wrote profile results to generator.py.lprof
            Timer unit: 1e-06 s

            Total time: 0.285665 s
            File: generator.py
            Function: main at line 4

            Line #      Hits         Time  Per Hit   % Time  Line Contents
            ==============================================================
                4                                           @profile
                5                                           def main():
                6         1     252972.0 252972.0     88.6      orders = [random.randint(0, 100) for _ in range(100_000)]
                7                                           
                8         1      14099.0  14099.0      4.9      comprehension = [2 * amount for amount in orders if amount > 50]
                9         1          2.0      2.0      0.0      generator = (2 * amount for amount in orders if amount > 50)
                10                                           
                11         1        237.0    237.0      0.1      sum(comprehension)
                12         1      18355.0  18355.0      6.4      sum(generator)


            mpatel@blr-mpd67 demos % python3 -m memory_profiler generator.py
            Filename: generator.py

            Line #    Mem usage    Increment  Occurrences   Line Contents
            =============================================================
                4   42.852 MiB   42.852 MiB           1   @profile
                5                                         def main():
                6   43.699 MiB    0.848 MiB      100003       orders = [random.randint(0, 100) for _ in range(100_000)]
                7                                         
                8   43.809 MiB    0.109 MiB      100003       comprehension = [2 * amount for amount in orders if amount > 50]
                9   43.809 MiB    0.000 MiB      149154       generator = (2 * amount for amount in orders if amount > 50)
                10                                         
                11   43.809 MiB    0.000 MiB           1       sum(comprehension)
                12   43.809 MiB    0.000 MiB           1       sum(generator)


            mpatel@blr-mpd67 demos % 

    Fast concatenation of strings
        Examples: items = ['hello','world']
            item[0] + item[1]       -> + operator is slow , very friendly and scalable.
            f'{item[0]}{item[1]}'   -> fstring is high in perfornce and friendly but no scalable as you need to know put items
            ''.join(items)          -> join high performance, less friendly but scalable and memory efficient
        use + only for basic work else use join only

        # Demo to check time and memory profile
            mpatel@blr-mpd67 demos % cat concatenation.py 
            import random


            @profile
            def main():
                orders = [str(random.randint(0, 100)) for _ in range(50_000)]

                report = ''
                for o in orders:
                    report += o
                
                ''.join(orders)


            main()%
            mpatel@blr-mpd67 demos % kernprof -lv concatenation.py 
            Wrote profile results to concatenation.py.lprof
            Timer unit: 1e-06 s

            Total time: 0.279477 s
            File: concatenation.py
            Function: main at line 4

            Line #      Hits         Time  Per Hit   % Time  Line Contents
            ==============================================================
                4                                           @profile
                5                                           def main():
                6         1     155684.0 155684.0     55.7      orders = [str(random.randint(0, 100)) for _ in range(50_000)]
                7                                           
                8         1          0.0      0.0      0.0      report = ''
                9     50001      15033.0      0.3      5.4      for o in orders:
                10     50000     107873.0      2.2     38.6          report += o
                11                                               
                12         1        887.0    887.0      0.3      ''.join(orders)

            mpatel@blr-mpd67 demos % python3 -m memory_profiler concatenation.py
            Filename: concatenation.py

            Line #    Mem usage    Increment  Occurrences   Line Contents
            =============================================================
                4   42.859 MiB   42.859 MiB           1   @profile
                5                                         def main():
                6   45.977 MiB    3.117 MiB       50003       orders = [str(random.randint(0, 100)) for _ in range(50_000)]
                7                                         
                8   45.977 MiB    0.000 MiB           1       report = ''
                9   47.777 MiB    0.000 MiB       50001       for o in orders:
                10   47.777 MiB    1.801 MiB       50000           report += o
                11                                             
                12   47.777 MiB    0.000 MiB           1       ''.join(orders)


            mpatel@blr-mpd67 demos % 

    Permission or forgiveness?
        If lot of bad data expected use Permission approach otherwise use forgiveness approach
        Permission approach checks with IF statements wheres as in forgiveness you use try except block 

        # Demo to see less bad data profile and so many bad data profile for both approach
            mpatel@blr-mpd67 demos % cat permission.py 
            import random


            def permission(orders):
                result = []
                for amount in orders:
                    if type(amount) == int:
                        if amount > 50:
                            result.append(2 * amount)
                return result


            def forgiveness(orders):
                result = []
                for amount in orders:
                    try:
                        if amount > 50:
                            result.append(2 * amount)
                    except TypeError:
                        pass
                return result


            @profile
            def main():
                orders = [random.randint(0, 100) for _ in range(100_000)]

                for i in range(10):
                    orders[i] = 'bad data'
                permission(orders)
                forgiveness(orders)

                for i in range(90_000):
                    orders[i] = 'bad data'
                permission(orders)
                forgiveness(orders)

                
            main()%
            mpatel@blr-mpd67 demos % kernprof -lv permission.py 
            Wrote profile results to permission.py.lprof
            Timer unit: 1e-06 s

            Total time: 0.492114 s
            File: permission.py
            Function: main at line 24

            Line #      Hits         Time  Per Hit   % Time  Line Contents
            ==============================================================
                24                                           @profile
                25                                           def main():
                26         1     262630.0 262630.0     53.4      orders = [random.randint(0, 100) for _ in range(100_000)]
                27                                           
                28        11          3.0      0.3      0.0      for i in range(10):
                29        10          4.0      0.4      0.0          orders[i] = 'bad data'
                30         1      44008.0  44008.0      8.9      permission(orders)
                31         1      32544.0  32544.0      6.6      forgiveness(orders)
                32                                           
                33     90001      23234.0      0.3      4.7      for i in range(90_000):
                34     90000      23921.0      0.3      4.9          orders[i] = 'bad data'
                35         1      27049.0  27049.0      5.5      permission(orders)
                36         1      78721.0  78721.0     16.0      forgiveness(orders)

            mpatel@blr-mpd67 demos %

    Faster functions
        calling function so many time can create some performance but it gives reusable, well maintainable code.
        # Demo
            mpatel@blr-mpd67 demos % cat functions.py 
            import random

            def get_random_integer():
                return random.randint(0, 100)


            @profile
            def main():
                [random.randint(0, 100) for _ in range(100_000)]
                [get_random_integer() for _ in range(100_000)]
                [(lambda: random.randint(0, 100))() for _ in range(100_000)]

                
            main()%
            mpatel@blr-mpd67 demos % kernprof -lv functions.py 
            Wrote profile results to functions.py.lprof
            Timer unit: 1e-06 s

            Total time: 0.868221 s
            File: functions.py
            Function: main at line 7

            Line #      Hits         Time  Per Hit   % Time  Line Contents
            ==============================================================
                7                                           @profile
                8                                           def main():
                9         1     270714.0 270714.0     31.2      [random.randint(0, 100) for _ in range(100_000)]
                10         1     289860.0 289860.0     33.4      [get_random_integer() for _ in range(100_000)]
                11         1     307647.0 307647.0     35.4      [(lambda: random.randint(0, 100))() for _ in range(100_000)]

            mpatel@blr-mpd67 demos %

    Optimizing numerical calculations
        Numpy - pupular, unofficial standard for scientific Computing, large ecosystem, optimized high performance 
        Pandas - relies on Numpy, data analysis and manipulation, good for tabular data, good for export, high performance
        # Demo to see how fast Numpy is. 
            mpatel@blr-mpd67 demos % cat numerical.py 
            import random
            import numpy as np

            def loop_approach(orders):
                result = 0
                for o in orders:
                    result += o * o
                return result

            def numpy_approach(orders):
                numpy_orders = np.array(orders)
                return np.sum(numpy_orders * numpy_orders)

            @profile
            def main():
                orders = [random.randint(0, 100) for _ in range(100_000)]
                loop_approach(orders)
                numpy_approach(orders)    
                
            main()%
            mpatel@blr-mpd67 demos % kernprof -lv numerical.py 
            Wrote profile results to numerical.py.lprof
            Timer unit: 1e-06 s

            Total time: 0.299079 s
            File: numerical.py
            Function: main at line 14

            Line #      Hits         Time  Per Hit   % Time  Line Contents
            ==============================================================
                14                                           @profile
                15                                           def main():
                16         1     272177.0 272177.0     91.0      orders = [random.randint(0, 100) for _ in range(100_000)]
                17         1      20994.0  20994.0      7.0      loop_approach(orders)
                18         1       5908.0   5908.0      2.0      numpy_approach(orders)    

            mpatel@blr-mpd67 demos %

    Interperter-based Optimizations
        Many interpreters 
            Running python code on hardware
            CPython - official interpreter
            PyPy - performance boost but not latest liek CPython
            Cython - C base interpreter for performance but not all features
            Jython - Java based
            Pyston - 
        
        # Demo to check diff on performance.
            # Install PyPy
            mpatel@blr-mpd67 demos % brew install pypy3
            mpatel@blr-mpd67 demos % cat sum_loop.py 
            import time


            def heavy_work():
                for _ in range(100_000_000):
                    do_stuff()


            def do_stuff():
                return 1 + 2

            start_time = time.time()
            heavy_work()
            end_time = time.time()
            print(f'Duration: {end_time - start_time: .2f} seconds')
            mpatel@blr-mpd67 demos % python3 sum_loop.py 
            Duration:  7.01 seconds
            mpatel@blr-mpd67 demos % pypy3 sum_loop.py 
            Duration:  0.11 seconds

    Risky Optimizations
        Tradeoffs
        Less maintainable code
        New bugs
        Much efforts, small gains

        # Examples to avoid
            Large, Self-sufficient function
            Alternative Python interpreter
            Multiple assignment

        # Demo to see multiple assignment but it shows not much benefit but clumsy code.
            mpatel@blr-mpd67 demos % kernprof -lv assignments.py 
            Wrote profile results to assignments.py.lprof
            Timer unit: 1e-06 s

            Total time: 0.97946 s
            File: assignments.py
            Function: main at line 11

            Line #      Hits         Time  Per Hit   % Time  Line Contents
            ==============================================================
                11                                           @profile
                12                                           def main():
                13         2     828823.0 414411.5     84.6      orders = [(random.randint(0, 100),
                14                                                          random.randint(0, 100),
                15         1          1.0      1.0      0.0                 random.randint(0, 100)) for _ in range(100_000)]
                16                                               
                17    100001      25454.0      0.3      2.6      for o in orders:
                18    100000      55789.0      0.6      5.7          multiple_assignments(o)
                19    100000      69393.0      0.7      7.1          individual_assignments(o)

            mpatel@blr-mpd67 demos % cat assignments.py
            import random

            def multiple_assignments(order):
                order_subtotal, order_tax, order_shipping = order

            def individual_assignments(order):
                order_subtotal = order[0]
                order_tax = order[1]
                order_shipping = order[2]

            @profile
            def main():
                orders = [(random.randint(0, 100),
                        random.randint(0, 100),
                        random.randint(0, 100)) for _ in range(100_000)]
                
                for o in orders:
                    multiple_assignments(o)
                    individual_assignments(o)

                
            main()%
            mpatel@blr-mpd67 demos %


4. Using more threads
    What are threads?
        Separate execution flows, Part of process, adds concurrency. but python have global interpreter lock but it can still improve performance
        Threads are Lightweight, have shared memory, potential for bugs to writes on variable and GIL (global interpreter lock) contraints 
        Processes are Heavyweight, Separate memory and low potential for bugs and no GIL constraint

            # Demo code with threads
            mpatel@blr-mpd67 demos % kernprof -lv more_threads.py 
            Processing order with id=10
            Processing order with id=20
            Wrote profile results to more_threads.py.lprof
            Timer unit: 1e-06 s

            Finished processing order with id=10
            Finished processing order with id=20
            mpatel@blr-mpd67 demos % cat more_threads.py
            import threading
            from time import sleep

            def process_order(order_id):
                print(f'Processing order with id={order_id}')
                sleep(1)
                print(f'Finished processing order with id={order_id}')

            first_thread = threading.Thread(target=process_order, args=(10,))
            second_thread = threading.Thread(target=process_order, args=(20,))

            first_thread.start()
            second_thread.start()
            mpatel@blr-mpd67 demos %
    
    Challenges
        Synchronizing threads
            Race conditions
            Deadlocks
            Starvation
            Livelocks
        Troubleshooting - Reproduction is difficult 
        GIL (global interpreter lock)
            Only one thread is allowed 
            Most impact on CPU intensive task so no much benefit if task are CPU intensive
        Usage: 
            Tasks that wait for external events
            Blocking I/O 
            Simple logic
        Dont Use:
            No waiting for external events
            Avoid for CPU intensive task
            complex task should not be used in threads

        # Demo
            mpatel@blr-mpd67 demos % kernprof -lv download_threads.py 
            Wrote profile results to download_threads.py.lprof
            Timer unit: 1e-06 s

            Total time: 2.93224 s
            File: download_threads.py
            Function: main at line 21

            Line #      Hits         Time  Per Hit   % Time  Line Contents
            ==============================================================
                21                                           @profile
                22                                           def main():
                23         1    2167637.0    2e+06     73.9      single_thread()
                24         1     764599.0 764599.0     26.1      multiple_threads()

            mpatel@blr-mpd67 demos % cat download_threads.py
            import threading
            from urllib import request


            def download():
                return request.urlopen('https://google.com').read()

            def single_thread():
                for _ in range(5):
                    download()

            def multiple_threads():
                threads = []
                for _ in range(5):
                    threads.append(threading.Thread(target=download))
                for t in threads:
                    t.start()
                for t in threads:
                    t.join()

            @profile
            def main():
                single_thread()
                multiple_threads()

            main()
            mpatel@blr-mpd67 demos % 


5. Using Asynchronous code
    Asynchronous code 
        Inspired from other langauge
        Reduce potential for bugs
        Maximize core utilization
        It have new syntax, concepts, tools
        only one thread is used so blocking code can stall everything
        Async code
            Low overhead
            Low potential for bugs
            Learning curve
            Compatibility constraint

    Challenges
        Learning Curve -> Async, await etc (new concept coroutine, event loop and new libraries aiohttp, aiomysql)
        Debugging 
        Compatibility
            need third party libraries
            blocking code not allowed
    
    When to use
        I/O operation, many small tasks, Avoid Synchronizing threads, 
        Examples : Data processing pipelines, network application

        # Demo to see perf improvement
            mpatel@blr-mpd67 demos % kernprof -lv download_asyncio.py 
            Wrote profile results to download_asyncio.py.lprof
            Timer unit: 1e-06 s

            Total time: 2.90191 s
            File: download_asyncio.py
            Function: main at line 23

            Line #      Hits         Time  Per Hit   % Time  Line Contents
            ==============================================================
                23                                           @profile
                24                                           def main():
                25         1    2539902.0    3e+06     87.5      synchronous()
                26         1     362007.0 362007.0     12.5      asyncio.run(asynchronous())

            mpatel@blr-mpd67 demos % cat download_asyncio.py
            import asyncio
            import aiohttp
            from urllib import request


            def download():
                return request.urlopen('https://google.com').read()

            def synchronous():
                for _ in range(5):
                    download()

            async def async_download(session, url):
                async with session.get(url) as response:
                    return await response.text()

            async def asynchronous():
                async with aiohttp.ClientSession() as session:
                    coroutines = [async_download(session, 'https://google.com') for _ in range(5)]
                    await asyncio.gather(*coroutines)


            @profile
            def main():
                synchronous()
                asyncio.run(asynchronous())

            main()%
            mpatel@blr-mpd67 demos %

6. Using more processes 
    Basics
        Separate memory spaces
        No GIL for process
        Utilize all CPU cores 
        Increased memory overhead
        Harder to share resources

    # Demo
        mpatel@blr-mpd67 demos % cat hello_dask.py 
        from dask.distributed import Client


        def clean_order(order_id):
            for _ in range(500_000_000):
                pass
            print(f"Finished cleaning order with id={order_id}")


        if __name__ == '__main__':
            client = Client()
            client.map(clean_order, [10, 20])    
            # first = Process(target=clean_order, args=(10,))
            # second = Process(target=clean_order, args=(20,))

            # first.start()
            # second.start()

            # first.join()
            # second.join()
        mpatel@blr-mpd67 demos % cat more_processes.py 
        from multiprocessing import Process


        def clean_order():
            for _ in range(500_000_000):
                pass
            print('Finished cleaning')

        if __name__ == '__main__':
            p1 = Process(target=clean_order)
            p2 = Process(target=clean_order)

            p1.start()
            p2.start()

            p1.join()
            p2.join()
        mpatel@blr-mpd67 demos % time python3 hello_dask.py
        python3 hello_dask.py  4.05s user 1.15s system 284% cpu 1.831 total
        mpatel@blr-mpd67 demos % time python3 more_processes.py 
        Finished cleaning
        Finished cleaning
        python3 more_processes.py  22.22s user 0.20s system 197% cpu 11.375 total
        mpatel@blr-mpd67 demos %


----------------------------
Python 3: Proficient Average
----------------------------

1. Given the following representation of a phone:
    class Phone:
        def __init__(self, memory):
            self.memory = memory
    What happens when you run the following code?
    pear = Phone(256)
    plum = pear
    pear.memory += plum.memory
    print(plum.memory)

    It prints 512.

2. What is the role of the __init__.py file in a package?
    It imports the directory as a package and lets the interpreter know about Python code.

3. You mention the location of your XYZ file in the path variable. You now must display the file path on the console so you write the following code:
    path = "The file is saved in the directory located at C:\Users\XYZ"
    print(path)
    When you run the code, you receive a SyntaxError: truncated \UXXXXXXXX escape. How can you resolve it?

    By prefixing the path string with r

4. How many iterations does the following while loop perform?
    counter = 0
    for i in range(4):
        counter += 1

    while(1):
        counter -= 1
        print(counter)

    Infinite

5. Which function can replace range(len(sequence)) in a for loop?
    enumerate()

6. A product in your inventory sold more than 10,000 units last year and more than 20,000 units this year. How can you find similar products from your inventory?
    inventory = ['ZKFL0', 'OJG5', 'JN4', 'FHTK3', 'XYRH2']
    lastYearSalesProdWise = [5000, 7000, 80000, 120000, 60000]
    thisYearSalesProdWise = [20000, 80000, 6000, 90000, 70000]

    # Expected output: 
    # FHTK3
    # XYRH2

    for i in range(len(lastYearSalesProdWise)):
        if lastYearSalesProdWise[i] > 10000 and \
        thisYearSalesProdWise[i] > 20000:
            print(inventory[i])

7. You have two strings saved in the variables previous and current. Both strings are saved using double quotes. How can you merge the strings in a single string by separating them with a colon :?
    previous + ':' + current

8. What would you add to the following code to raise an exception if the file is empty?
    try:
        f = open('path/file.txt')
    except FileNotFoundError as e:
        print(e)

    try:
        f = open('path/file.txt')
            if f.read() == '':
                raise Exception
    except FileNotFoundError as e:
        print(e)
    except  Exception:
        print('File is empty')

9. Which keyword makes a generator?
    yield

10. Given the following function: 
    def quadratic(a, b, c, *args, **kwargs):
    # ...
    What values end up in args for the following call?
    quadratic(31, 93, 62, 13, e=42)

    [13]

11. For a list, what is the difference between the extend() and append() methods?
    extend() adds multiple elements, whereas append() adds only one element.

12. What is a coroutine?
    A variant of functions that you use for cooperative multi-tasking

13. How many numbers are printed on the console using the following code?
    mySeq = [20, 88, 40, 99, 60, 11, 100]
    for i in range(-4, -2, 7):
        print(mySeq[i])
    1

14. What is the difference between the import and from import statements?
    from import binds members of the main module, whereas import binds the main module.

15. You have a sequence with string and integer elements. You find the sum of all the integers using the following method:
    seq = ['price', 'sales', 300, 400, 500, 'turnover']
    mySum = 0
    for i in seq:
        if isinstance(i, int):
            mySum += i
    print(mySum)                 # 1200
    Later, you use list comprehension to modify the code print(sum([i if isinstance(i, int) for i in seq])) which results in a syntax error. How can you change the comprehension to resolve the error?

    print(sum([i for i in seq if isinstance(i, int)]))

16. For a 2D video game the hero can walk or ride a horse. When encountering an obstacle, the game engine calls hero.jump(). If the hero is riding, they pass the command to the horse. You have the following horse implementation:
    class Horse(Sprite):
        def __init__(self, color, speed):
            self.color = color
            self.speed = speed
        def render(self):
            # ... implementation ...
            pass
    What must you add to make the horse obey the hero?

        def jump(self): 
            # ...

17. Which is a valid function definition?
    def m4m4_m14(self):
        pass

18. For a game room, you receive orders such as:
    o1 = {
        'bowling': 3,
        'pool': 4,
        'air-hockey': 2
    }
    This means that first there will be three players for bowling, then another one joins and they play pool, and finally two leave and the remaining want to play air-hockey. You want to check if two orders are the same so you can optimize resource allocation:
    if o1 == o2:
        # propose that players wait a bit
        ...
    This does not work because it marks the following as equivalent to o1:
    o2 = {
        'air-hockey': 2,
        'bowling': 3,
        'pool': 4,
    }
    How would you solve it?

    Use OrderedDictionary instead of dict to keep track of the orders.

19. The following function splits a list of integers into even numbers and odd numbers:
    def split_even_odd(iter):
        evens = []
        odds = []
        for item in iter:
            if item % 2 == 0:
                evens.append(item)
            else:
                odds.append(item)
        return evens, odds
    What is the result of the following line of code?
    a, _ = split_even_odd([1,2,3])

    The variable a contains [2].

20. You must accept an integer input limit from a user and print all the squares of the numbers ranging from 0 to the number that the user specifies. During the operation, you do not perform the square operation on the number 2 and delete the variable limit when the operation is complete. How would you write its logic?
    Incorrect -
    limit = int(input("Your number"))
    for i in range(limit):
        print( i**2 )
    else:
        del limit


    limit = int(input("Your number: "))
    for i in range(limit):
        if i == 2:
            pass
        else:
            print( i**2 )
    else:
        del limit

## Date Taken : 17-July-2024
1. How many direct ancestors can a class have?

    As many as needed

2. When should you use a generator expression rather than a list comprehension?

    When you want the system to prefer lazy evaluation

3. You expect the output of the arithmetic operation in the following code to be 5.0 but it comes out to be 1:
var1 = 25
var2 = 2
var3 = var1 ** (var2 // 4)
print(var3)
What fixes must you make in the code to arrive at 5.0?

    Change // to /.

4. The following dictionary represents animals and their counts:
sequence = {"animals": ["panda", "deer", "lion", "eagle"], 
            "counts": ["10", "5.23", "8.0", 12]}
Because of a glitch, two of the four animal counts have decimal numbers appended to them. How can you convert each count from a string to an integer type and remove any available decimal numbers?

    l = []
    for k, v in sequence.items():
        if k == "counts":
            for i in v:
                l.append(int(float(i)))

    sequence["counts"] = l

    In [10]: int(float("2.1"))
    Out[10]: 2
    In [11]: int("2.1")
    ValueError: invalid literal for int() with base 10: '2.1'

5. You create a context manager for connecting to a MySQL database:
    from contextlib import contextmanager
    import mysql.connector
    import pandas as pd

    @contextmanager
    def mySQLDB(db):
    conn = mysql.connector.connect(user='user', 
                                    password='password', database=db)
    yield conn
    conn.close()

    How can you use the context manager to retrieve all records from a table named Test from a database TestDB?
    
    with mySQLDB(db = 'TestDB') as conn:
    data = pd.read_sql('SELECT * FROM Test', conn)

6. A dictionary holds the grades as percentages of five students as follows:
    myDict = {"percentages": [50, 88, 61, 98, 78]}
How can you extract each percentage and store them in five separate variables?

    s1, s2, s3, s4, s5 = myDict["percentages"]


7. A string holds the information about the radius of a circle and the side of a square respectively as follows:
    target = "Circle radius=2 Square side=4"
You must extract the values of both these parameters in a tuple format [('radius', '2'), ('side', '4')]. To do so, you use the code re.findall(r'(\W+)=(\d+)', target) which results in an empty list. 
What changes must you make in the regular expression to arrive at the output you expect?

    re.findall(r'(\w+)=(\d+)', target)
    # CAP W cant work

8. What is the benefit of using a context manager while connecting to different databases in Python?
    You can assure the connections of databases are closed after performing the required operations.


9. What is true for relative import?
    It can turn long import statements into short statements depending on its current location.


10. In a class, how do you make a method that takes the class as the first parameter instead of self ?
    @classmethod

11. You are developing a package called x1 in Python 3 which has a sub package called x2. Which is a correct directory tree for package x1?

    x1
    --__init__.py
    x2
    --__init__.py
    --x2.py
    --x1.py


12. You have a sequence with duplicate numbers. You write the following code to find the number of occurrences for each integer:
    import numpy as np
    sequence = [7, 8, 8, 8, 7, 7, 2, 2, 2, 2, 2, 10]
    foo = np.unique(sequence, return_counts=True)
    print(foo)

    # Output
    # (array([ 2,  7,  8, 10]), array([5, 3, 3, 1]))
The output stored inside the variable foo is in the form of a tuple. What changes can you make to the code to retrieve the duplicate numbers and their counts in separate variables with the least effort?

    Change the foo assignment to:
    foo, bar = np.unique(sequence, return_counts=True)


13. How do you collect all keyword arguments passed to a function?
    By prefixing the last parameter with **


14. You have a list of 20 elements in myList. Each element is of type float. You must print the first item from the list without checking any conditions and print the rest of the items that are divisible by 4.2. How would you write the code?
    length = len(myList)
    idx = 0
    print(myList[idx])

    while(idx < length-1):
        idx += 1    
        if myList[idx] % 4.2 == 0:
            print(myList[idx])


15. Which if conditions are true in the following code?
if 8:
    if -9:
        if '.':
            if '0':
                if 0:
                    print("Pass")

    if 8, if -9, if '.', and if '0'


16. Given a list of 10 elements, which operation always results in exactly one element?
    functools.reduce()

17. When should you use a lambda function instead of a named function?
    When you only need a short one-line function 

18. Given a set s, what is the difference between s.remove(x) and s.discard(x)?
    s.remove(x) can raise an error, whereas s.discard(x) always works.

19. The if and elif statements have two conditions each. Which conditions must be false to arrive at the output Que?
    if (5 == 4 and 8 < 80) and (3 == 3 and 4 == 4):
        print("Foo")
    elif (isinstance("hi", str) or 8) and (9 and 1):
        print("Baz")
    else:
        print("Que")

    Any condition in the if statement and any condition in the elif statement


20. How can you save the following text with its current format in a string variable?
I am working on a Python script.
I don't feel tired even if I work eight hours straight.

    myVar = '''I am working on a Python script.
    I don't feel tired even if I work eight hours straight.'''


### Date taken : 2 Aug 2024
1. You try to run an asynchronous function. You try to call it, but it is not working. How can you call an asynchronous function?
asyncio.run(functionName())
functionName.run()
asyncIO(functionName())
thread.FunctionName()

    asyncio.run(functionName())

2. You write the following code to print three numbers, 1, 2, and 3, on one line:
i = 1
while i < 4:
    print(i)
    i += 1

# Expected output: 1 2 3
The code returns the numbers you want but on separate lines. What fixes must you make to the code?
Update print(i) to print(i, " ").
Update print(i) to print(i, end=" ").
Update print(i) to pprint.PrettyPrinter(i).
Update print(i) to pprint.PrettyPrinter().pprint(i).

    ANS: Update print(i) to print(i, end=" ").

3. What is an example of list comprehension?
Incorrect -
a = []
for s in 'MON TUE WED'.split():
    a.append(s)
Incorrect -
a = list(map(int, [0.1, 1.5, 2.0, 3.0]))
Your choice: correct -
a = [s.lower() for s in 'MON TUE WED'.split()]
Incorrect -
a = filter(lambda x: x < 42, [10, 44, 50, 41, 4])

4. You write code to accept a number from your users and to check if the number belongs within the range 0-100, both inclusive as follows:
myInput = input("Enter a decimal number")
if myInput in range(100):
    print("Success")
else:
    print("Failure")
On testing, you input a number 5.6 and you receive a failure on the console. What fixes must you make in the code?
Incorrect -
Change the input statement:

myInput = input("Enter a decimal number", dtype=numpy.float32)
Incorrect -
Change the if statement:

if float(myInput) in range(100):
Incorrect -
Change the input statement:

myInput = input("Enter a decimal number", dtype=float)
Your choice: correct -
Change the if statement:

if float(myInput) >= 0 and float(myInput) <= 100:


5. A base Cake class takes care of assembling a cake:
class Cake(ABC):
    def __init__(self, layers, filling):
        self.layers = layers
        self.filling = filling
 
    def assemble(self):
        self.base = filling.join(layers)
        return self.base

    @abstractmethod
    def decorate(self):
        return 'cherry'
Given the following BlackForest specialization of Cake, what is the next step to ensure you can build a BlackForest object?
def BlackForest(Cake):
    # ...
Incorrect -
Implement the assemble() method.

Your choice: incorrect -
Declare the layers and filling.

Incorrect -
Declare an @abstractmethod with the name decorate().

Correct -
Implement the decorate() method.



6. A class displays the statistics of your business for an analyst:
class Stats:
    locale = 'en_US'
    def __init__(self, sales, costs):
        self.profit = sales - costs

    def show(self):
        if self.locale == 'en_US':
            print(f'USD {self.profit}')
        elif self.locale == 'en_GB':
            print(f'GBP {self.profit * 0.8}')
January was a bad month:
jan = Stats(7, 10)
jan.show() 
# USD -3
To make up for it, you hire an analyst in London to boost sales. When the February stats come in, the analyst chooses to display the currency in GBP:
feb = Stats(14, 10)
feb.locale = 'en_GB'
jan.show()
feb.show()
jan is still in USD. Why does this happen, even though locale is a class variable?
Incorrect -
The locale variable is not decorated with @classproperty.

Incorrect -
The feb object was created after the jan object.

Your choice: correct -
The locale is set as a new instance attribute for feb.

Incorrect -
The jan value is cached.

7. How many elements does the following indexing operation extract?
seq = [5, 6, 9, 1, 5, 1, 1, 3, 0]
print(seq[:2:])
Your choice: incorrect -
4

Incorrect -
7

Incorrect -
5

Correct -
2

8. In the following class Person, _age is a private attribute.
class Person:
    def __init__(self, age, say_age=True):
        self._age = age
        self.say_age = say_age

    @property
    def age(self):
        if self.say_age:
            return self._age
        return None
Why does the following code snippet print 42 and not throw an error?
p = Person(42, say_age=False)
print(p._age)
Incorrect -
It does not use the @property decorator correctly and leaks the underlying value.

Your choice: incorrect -
_age stops being private when you assign a value to it in __init__().

Correct -
The variable _age is private by convention, not enforced by the interpreter.

Incorrect -
It does not use the attribute say_age correctly in the code.

Incorrect -
I don't know yet.


9. Which function of the timeit module returns the time it takes for Python code to run?
Your choice: correct -
timeit()

Incorrect -
test()

Incorrect -
print_exec()

Incorrect -
timer()

Incorrect -
I don't know yet.

10. You manually stop the iterations that the following code generates:
mySeq = [96, 8, 10, 98, 45, 32, 101]
idx = 0
while(idx < 7):    
    if mySeq[idx] == 32:
        break
    else:
        continue
print(idx)
What is the value of the variable idx?
Incorrect -
6

Incorrect -
7

Correct -
0

Incorrect -
5


11. How would you create a context manager generator for a MySQL database on the same system with user = 'user1' and password = 'test'?
Incorrect -
from contextlib import contextmanager
import mysql.connector
@contextmanager
def mySQLDB(db):
  conn = mysql.connector.connect(user = 'user1', password = 'test')
  yield conn
  conn.close()
Your choice: correct -
from contextlib import contextmanager
import mysql.connector
@contextmanager
def mySQLDB(db):
  conn = mysql.connector.connect(user = 'user1', password = 'test', database = db)
  yield conn
  conn.close()
Incorrect -
from contextlib import contextmanager
@contextmanager
def mySQLDB(db):
  conn = connect(user = 'user1', password = 'test', database = 'db')
  yield conn
  conn.close()
Incorrect -
import contextmanager
import connector
@contextmanager
def mySQLDB(db):
  conn = connect(user = 'user1', password = 'test', database = 'db')
  yield conn
  conn.close()
Incorrect -
I don't know yet.


12. You create all unit test cases for your code to test its functionality in a file named test_mod1.py. When you try to run your test cases using the command py test_mod1.py, nothing happens. You then try another command: py -m unittest test_mod1.py. All test cases run, showing results. What kind of update can you make to run the test cases using the first command?
Incorrect -
Add test_mod1.py in the main module directory.

Incorrect -
Remove test_mod1.py from the main module directory.

Incorrect -
Include the following code in test_mod1.py: 

unittest.setUpModule():
 createConnection()
Your choice: correct -
Include the following code in test_mod1.py:

if __name__ == '__main__':
 unittest.main()
Incorrect -
I don't know yet.

13. What is multithreading in Python?
Your choice: correct -
A way of adding concurrency to a program using multiple lightweight execution paths

Incorrect -
The technique of running multiple programs at the same time, each in its own memory space

Incorrect -
A coding convention that developers must follow to have consistency in projects

Incorrect -
A set of Python commands you run to generate a wheel for a module

Incorrect -
I don't know yet.


14. Which code snippet returns how long it takes the following code to run?
x = 0
while  x<= 100000:
    x  += 1
Incorrect -
import timeit
print(timeit.timer(stmt = 'while  x<= 100000:    x  += 1', setup = 'x = 0', number = 100000))
Incorrect -
import timeit
print(timeit.time(stmt = 'while  x<= 100000:    x  += 1',  number = 100000))
Incorrect -
import timeit
print(timeit.printexec(stmt = 'x = 0  while  x<= 100000:    x  += 1',  number = 1))
Your choice: correct -
import timeit
print(timeit.timeit(stmt = 'while  x<= 100000:    x  += 1', setup = 'x = 0', number = 1))
Incorrect -
I don't know yet.



15. Given the following class:
class A:
    @classmethod
    def inspect(x):
        print(x.__name__)
What does this code produce?
a = A()
a.inspect()
Correct -
A
Incorrect -
x
Incorrect -
None
Your choice: incorrect -
a
Incorrect -
I don't know yet.


16. How many functions with the same name can you define in the same scope?
Your choice: incorrect -
Up to two, one with positional arguments and one with keyword arguments

Incorrect -
As many as you need, as long as the names of the arguments are different

Correct -
Only one, with any mix of positional and keyword arguments

Incorrect -
As many as you need, as long as the arguments have different type annotations

Incorrect -
I don't know yet.

17. When would there be multiple tracebacks?
Correct -
When multiple exceptions are raised during execution

Your choice: incorrect -
When imported modules have raised exceptions

Incorrect -
When exception chains are not implemented correctly

Incorrect -
When modules are not available

Incorrect -
I don't know yet.


18. Given the following representation of a phone:
class Phone:
    def __init__(self, memory):
        self.memory = memory
What happens when you run the following code?
pear = Phone(256)
plum = pear
pear.memory += plum.memory
print(plum.memory)
Incorrect -
It prints 0.

Your choice: incorrect -
It prints 256.

Correct -
It prints 512.

Incorrect -
It throws an error.

Incorrect -
I don't know yet.


19. An artificial intelligence (AI) model takes a pair of clothing items and returns whether they are formal or informal wear:
def formal(clothing, shoes):
    # ...
    # complex AI model
    # ...
    return True
Because this calculation takes a long time, you want to store the results in a mapping for the following common pairings:
styles = [
    ['red dress', 'stiletto'],
    ['jeans', 'moccasin'],
    ['tuxedo', 'brogue'],
    ['shorts', 'sandals'],
]
You write the following code for this, but it throws an error about "Unhashable types". Why could this be?
is_formal = {style: formal(*style) for style in styles}
Incorrect -
You cannot store the return type from formal() in the dictionary. Convert it to string.

Correct -
The dictionary cannot store lists as keys. Convert style to tuple.

Your choice: incorrect -
The dictionary comprehension does not allow you to expand style into arguments for formal().

Incorrect -
The key and the value are in the wrong order. Use formal(..): style in the comprehension.

Incorrect -
I don't know yet.


20. Besides the () operator, which operator has a higher precedence than the / operator to perform a mathematical operation?
Your choice: incorrect -
//

Incorrect -
+

Correct -
**

Incorrect -
*

Incorrect -
I don't know yet.


Python 3: Proficient Above Average  # Date taken: 2 Aug 2024
----------------------------

1. A function takes a string and prints it if it fulfills a condition that a user provides:
def print_if(string, cond):
    if cond(string):
        print(string)
The user wants to display the word that starts with the lowercase letter v. How would you call the print_if() function to display the string vikings?
Your choice: correct -
print_if("vikings", lambda w: w.startswith('v'))
Incorrect -
print_if.__code__ = "return s.startswith('v')"
print_if("vikings", the_filter)
Incorrect -
def the_filter(s):
    return s.startswith(r'V|v')
print_if("vikings", the_filter)
Incorrect -
def the_filter(s):
    return s.init('v')
print_if("vikings", the_filter)
Incorrect -
I don't know yet.


2. Which class are all built-in exceptions derived from?
Incorrect -
Traceback

Incorrect -
Exception

Your choice: correct -
BaseException

Incorrect -
Eaccess

Incorrect -
I don't know yet.


3. Which decorator implements a getter in Python?
Incorrect -
@get
Incorrect -
@getter
Incorrect -
@property.get
Your choice: correct -
@property
Incorrect -
I don't know yet.


4. What is true about running code using threading in Python?
Your choice: correct -
All programs run concurrently with improved CPU usage.

Incorrect -
All programs run faster.

Incorrect -
After one thread finishes running, other threads can run at the same time.

Incorrect -
All threads run consecutively.

Incorrect -
I don't know yet.


5. In a Python class, how do you access a class instance variable with the syntax __foo?
Incorrect -
_Classname__foo
Correct -
Classname._Classname__foo
Your choice: incorrect -
Classname.__foo
Incorrect -
Classname.Classname__foo
Incorrect -
I don't know yet.


6. A program must ask users the number of integers they want to feed to the system and later request those numbers. Once accepted, the program must display the numbers as a list after multiplying each number by 10. To do so, you write the following program:
totNumbers = int(input("How many numbers you want to feed? "))
myNums = []
for i in range(totNumbers):    
    userNumber = int(input("Enter a number: "))
    userNumber *= 10
    myNums.append(userNumber)
 
for i in myNums:
    print(i)
The program results in the correct answer but not in a single list format. What changes would you make to the code to resolve the issue?
Your choice: incorrect -
Wrap the variable i within square brackets [].

Correct -
Add a comma after myNums in the for loop definition.

Incorrect -
Remove int() type casting from both the input streams.

Incorrect -
Change print(i) to print(myNums.append(i)).

Incorrect -
I don't know yet.


7. Given the following lists:
m = [3, 5, 7, 9, 11]
n = [2, 4, 6 ]
What is the output of the following code?
for i, (j, k) in enumerate(zip(m, n), 1):
    print(i + j + k)
Incorrect -
6
10
14
Incorrect -
6
10
14
10
12
Incorrect -
10
15
Correct -
6
11
16
Incorrect -

8. Which relational operation returns a logical True value? (ASCII comparison happens)
Your choice: incorrect -
print("10" >= "5")
Correct -
print("A" < "b")
Incorrect -
print("10" > "b")
Incorrect -
print("Z" > "b")
Incorrect -
I don't know yet.


9. The following if/else logic should display the body of the first print statement but instead, it returns a syntax error. Why?
if 8 > 4 & 8 != None:
    if 9:
        if isinstance("foo", str):
            print('Inner ifs reached!')
    else 8:
        print("Second if condition negated")
else 2 < 80:
    print("First if condition negated.")
Incorrect -
The if 9 condition is false and the interpreter also negates the else 8 condition.

Correct -
You passed conditions to the else statements.

Your choice: incorrect -
You used the & operator instead of the && operator.

Incorrect -
You passed str without round brackets () at its end.

Incorrect -
I don't know yet.


10. You have a list called l of pairs of numbers such as [(1, 2), (2, 2), (1, 2)]. How would you check if l has duplicated pairs?
Your choice: correct -
len(l) == len(set(l))
Incorrect -
any(p in l for p in l)
Incorrect -
all(p in l for p in l)
Incorrect -
len(l) == len(tuple(l))
Incorrect -
I don't know yet.


11. You have an integer 16. You must find its square root so that the result, when passed in the following expression, results in the integer 54:
initialNumber = 16
print(expectedSqRoot | 50) # Expected output: 54
How would you write the code for the variable expectedSqRoot?
Incorrect -
import math
expectedSqRoot = math.sqrt(initialNumber, dtype=int)
Incorrect -
import math
expectedSqRoot = math.isqrt(initialNumber, dtype = int)
Correct -
import math
expectedSqRoot = math.isqrt(initialNumber)
Your choice: incorrect -
import math
expectedSqRoot = math.sqrt(initialNumber)

isqrt give int so you can do binary or (|) on it.


12. The following function has an incomplete type annotation. What would you add so you have correct annotations?
def get_notifs(account_name: str = None):
    if account_name is None:
        account_name = 'Admin'
    res = requests.get(f'{base_url}/{account_name}/notifs')
    if res.status == 200:
        return res.json()
Incorrect -
def get_notifs(account_name: str = None) -> Optional[dict]:
    # ...
Your choice: incorrect -
def get_notifs(account_name: Optional[str] = None) -> Optional[str]:
    # ...
Correct -
def get_notifs(account_name: Optional[str] = None) -> Optional[dict]:
    # ...
Incorrect -
def get_notifs(account_name: Optional[str] = None) -> dict:
    # ...
Incorrect -
I don't know yet.

Return type json will fit into Optional[dict]


13. The following code should transpose matrix m using list comprehension. It does not generate a matrix, however. Which comprehension is the correct way to do this?
[row[i] for i in range(len(m[0])) for row in m]
Incorrect -
[col for row in m for col in row]
Incorrect -
[ row[i] for row in m for i in range(len(m[0])) ]
Your choice: correct -
[ [row[i] for row in m] for i in range(len(m[0])) ]
Incorrect -
[ [row[i] for i in range(len(m[0]))] for row in m ]
Incorrect -
I don't know yet.


14. What is the difference between aggregation and composition in object-oriented programming (OOP)?
Incorrect -
Aggregation represents a one-to-one relationship. Composition represents a one-to-many relationship. 

Correct -
In aggregation, the objects' life cycles are independent. In composition, the life cycle of one object depends on the life cycle of the other object.

Your choice: incorrect -
In aggregation, the life cycle of one object depends on the life cycle of the other object. In composition, the objects' life cycles are independent. 

Incorrect -
Aggregation represents a one-to-many relationship. Composition represents a one-to-one relationship.

Incorrect -
I don't know yet.

15. Given the following set:
s = {'blue', 'yellow', 'orange'}
And the following operations on it:
s.add('red')
s.update({'blue', 'green', 'yellow'})
s.remove('yellow')
How many times can you call s.pop() without an error?
Incorrect -
3

Correct -
4

Incorrect -
5

Your choice: incorrect -
6

Incorrect -
I don't know yet.

    s.add() and s.update() can add or update if item doesnt exits


16. A piece of code is wrapped in a try/except block. If the code raises no exception, then you want to print the message "Successful Execution". How would you do that?
Incorrect -
Add a pass statement, then print the message.

Correct -
Add an else clause with the print statement.

Your choice: incorrect -
Add a print statement after the try/except block.

Incorrect -
Add an except clause with the print statement.

Incorrect -
I don't know yet.


17. Given the following lists, which line adds all elements of a at the end of b ?
a = ['apple', 'banana', 'cherry']
b = ['jackfruit']
Incorrect -
a.append(b)
Your choice: correct -
b.extend(a)
Incorrect -
a.extend(b)
Incorrect -
b.append(a)
Incorrect -
I don't know yet.


18. Which function uses f as a callback?
Correct -
def use(l, f):
    for i in l:
        if len(i) > 5:
            f('found')
Your choice: incorrect -
def use(l):
    def f():
        if l < 0:
            return True
        return False
    return f
Incorrect -
def use(l, f):
    if random.random() < 0.5:
        return f
    return l
Incorrect -
def use(l, f):
    if l == 'DEBUG':
        print(f.__annotations__)
Incorrect -
I don't know yet.


19. The following function returns True if the items in sequence b add up to a larger total than the sum of even items in sequence a:
def larger_evens(a, b):
    sum = 0
    for num in a:
        if num % 2 == 0:
            sum += num
 
    total_b = sum(b)
    return total_b > sum
Calling this function results in an error 'int' object is not callable, however. Why?
Incorrect -
Sequence b is a tuple, not a list.

Correct -
You redefined the built-in sum() function.

Incorrect -
One of the sequences contains non-integer items.

Your choice: incorrect -
Sequence a is a tuple, not a list.

Incorrect -
I don't know yet.



20. You expect the output of the arithmetic operation in the following code to be 5.0 but it comes out to be 1:
var1 = 25
var2 = 2
var3 = var1 ** (var2 // 4)
print(var3)
 What fixes must you make in the code to arrive at 5.0?
Incorrect -
Change // to %.

Your choice: correct -
Change // to /.

Incorrect -
Change ** to *.

Incorrect -
Change ** to -.

Incorrect -
I don't know yet.

----------------------------
Advanced Python: Build Hands-On Projects with Design Patterns
----------------------------
1. Design patterns are _____.
Design patterns are language-neutral.

2.Which object-oriented mechanism does polymorphism rely on?
Inheritance allows child classes instantiated and treated as the same type as their parent.

3.Which of these patterns is a Creational pattern?
The Builder pattern is for creating a complex object.

4.Which of the following is a functional requirement?
Drawing a circle is what software does.

5.Behavioral patterns focus on _____.
Protocols dictate how interactions work.

6.Which of these is a characteristic of an architectural pattern?
Architectural patterns address global concerns affecting the quality of the entire software.


1.What pattern type does the Adapter pattern belong to?
Structural
Adapter is a structural pattern.


----------------------------
Hands-On Advanced Python: Data Exploration and Manipulation
----------------------------